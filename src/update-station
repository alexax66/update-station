#!/usr/local/bin/python
"""This is the main file for the update-station application"""

import bectl
import datetime
import getpass
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')
import json
import os
import gettext
import re
import socket
import sys
import threading
from gi.repository import Gtk, GLib, Notify
from subprocess import Popen, PIPE, run
from time import sleep
from updateHandler import (
    get_pkg_upgrade_data,
    check_for_update,
    network_stat,
    repo_online,
    look_update_station,
    unlock_update_station,
    updating,
    repository_is_syncing
)

gettext.bindtextdomain('update-station', '/usr/local/share/locale')
gettext.textdomain('update-station')
_ = gettext.gettext

lib_path: str = f'{sys.prefix}/lib/update-station'

__VERSION__ = '4.8'

username = os.environ.get('SUDO_USER') if 'SUDO_USER' in os.environ else getpass.getuser()
home = os.path.expanduser('~')


class Data:
    """
    Cla
    Attributes:
        backup: Boolean that indicates if the update-station should back up the current boot environment.
        close_session: Boolean that indicates if the update-station should close the session.
        packages_dictionary: Dictionary that contains all the packages that are installed on the system.
        second_update: Boolean that indicates if the update-station should do 2 update.
        stop_pkg_refreshing: Boolean that indicates if the update-station should stop refreshing the packages.
        total_packages: Integer that indicates the total number of packages that are that will be updated.
        update_started: Boolean that indicates if the application has started updating the system.
    """
    backup: bool = False
    close_session: bool = False
    packages_dictionary: dict = {}
    second_update: bool = False
    stop_pkg_refreshing: bool = False
    total_packages: int = 0
    update_started: bool = False


class UpdateWindow:
    """
    Class that creates the main window to see update list and start the update process.
    """
    def delete_event(self, widget: Gtk.Widget) -> None:
        """
        Function that handles the delete event when the window is closed.
        :param widget: The widget that triggered the delete event.
        """
        if Data.close_session is True:
            if updating():
                unlock_update_station()
            Gtk.main_quit()
        else:
            self.window.destroy()
            if Data.update_started is False:
                Data.stop_pkg_refreshing = False
                if updating():
                    unlock_update_station()
                tray.tray_icon().set_visible(True)

    def start_update(self, widget):
        """
        Function that starts the update process.
        :param widget: The widget that triggered the start update event.
        """
        Data.update_started = True
        InstallUpdate()
        self.window.hide()

    def if_backup(self, widget):
        """
        Function that handles the backup checkbox.
        :param widget: The widget that triggered the checkbox event.
        """
        Data.backup = widget.get_active()

    def create_bbox(self):
        """
        Function that creates the button box.
        :return: The button box.
        """
        table = Gtk.Table(
            n_rows=1,
            n_columns=5,
            homogeneous=False,
            column_spacing=5
        )
        backup_checkbox = Gtk.CheckButton(
            label=_("Create boot environment backup")
        )
        table.attach(backup_checkbox, 0, 1, 0, 1)
        backup_checkbox.connect("toggled", self.if_backup)
        if len(bectl.get_be_list()) >= 2 and Data.second_update is False:
            backup_checkbox.set_active(True)
            backup_checkbox.set_sensitive(True)
        else:
            backup_checkbox.set_active(False)
            backup_checkbox.set_sensitive(False)
        Data.backup = backup_checkbox.get_active()
        img = Gtk.Image(icon_name='window-close')
        close_button = Gtk.Button(label=_("Close"))
        close_button.set_image(img)
        table.attach(close_button, 3, 4, 0, 1)
        close_button.connect("clicked", self.delete_event)
        install_button = Gtk.Button(label=_("Install update"))
        table.attach(install_button, 4, 5, 0, 1)
        install_button.connect("clicked", self.start_update)
        return table

    def __init__(self):
        """
        The constructor for the UpdateWindow class.
        """
        self.window = Gtk.Window()
        self.window.connect("destroy", self.delete_event)
        self.window.set_size_request(700, 400)
        self.window.set_resizable(False)
        self.window.set_title(_("Update Manager"))
        self.window.set_border_width(0)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=0)
        box2.set_border_width(20)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        # Title
        title_text = _("Updates available!")

        update_title_label = Gtk.Label(
            label=f"<b><span size='large'>{title_text}</span></b>"
        )
        update_title_label.set_use_markup(True)
        box2.pack_start(update_title_label, False, False, 0)
        self.tree_store = Gtk.TreeStore(str, bool)
        sw = Gtk.ScrolledWindow()
        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.view = Gtk.TreeView(model=self.store())
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        sw.add(self.view)
        sw.show()
        box2.pack_start(sw, True, True, 10)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, False, 5)
        box2.show()
        # Add button
        box2.pack_start(self.create_bbox(), True, True, 10)
        self.window.show_all()

    def store(self):
        """
        Function that creates the store for the list of package in the treeview.
        :return: The store for the list of package to be updated.
        """
        self.tree_store.clear()
        r_num = 0
        u_num = 0
        i_num = 0
        ri_num = 0
        if bool(Data.packages_dictionary['remove']):
            r_num = len(Data.packages_dictionary['remove'])
            message = _('Installed packages to be REMOVED:')
            message += f' {r_num}'
            r_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['remove']:
                self.tree_store.append(r_pinter, (line, True))
        if bool(Data.packages_dictionary['upgrade']):
            u_num = len(Data.packages_dictionary['upgrade'])
            message = _('Installed packages to be UPGRADED')
            message += f' {u_num}'
            u_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['upgrade']:
                self.tree_store.append(u_pinter, (line, True))
        if bool(Data.packages_dictionary['install']):
            i_num = len(Data.packages_dictionary['install'])
            message = _('New packages to be INSTALLED:')
            message += f' {i_num}'
            i_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['install']:
                self.tree_store.append(i_pinter, (line, True))
        if bool(Data.packages_dictionary['reinstall']):
            ri_num = len(Data.packages_dictionary['reinstall'])
            message = _('Installed packages to be REINSTALLED:')
            message += f' {ri_num}'
            ri_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['reinstall']:
                self.tree_store.append(ri_pinter, (line, True))
        Data.total_packages = r_num + u_num + i_num + ri_num
        return self.tree_store

    def display(self, model: Gtk.TreeStore) -> Gtk.TreeView:
        """
        Function that creates the treeview.

        :param model: The store for the list of package to be updated.
        :return: The treeview.
        """
        self.view = Gtk.TreeView(model=model)
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        return self.view


class UpdateNotifier:

    def __init__(self):
        self.notification = None
        Notify.init('Test')
        self.msg = _("System and software upgrades are now available")
        self.timeout = 10000 # 10 seconds

    def notify(self):
        self.notification = Notify.Notification.new(
            summary='Update Available',
            body=self.msg,
            icon='system-software-update'
        )
        self.notification.add_action('clicked', 'Start Upgrade', self.on_activated)
        self.notification.show()
        # GLib.idle_add(notification.show)

    def on_activated(self, notification, action_name, data=None):
        StartCheckUpdate()
        notification.close()


class TrayIcon:
    """
    The class for the tray icon.
    """

    def tray_icon(self):
        return self.status_icon

    def __init__(self):
        """
        The constructor for the TrayIcon class.
        """
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_tooltip_text('Update Available')
        self.menu = Gtk.Menu()
        self.menu.show_all()
        self.status_icon.connect("activate", self.left_click)
        self.status_icon.connect('popup-menu', self.icon_clicked)
        self.status_icon.set_visible(False)
        self.status_icon.set_from_icon_name('system-software-update')

    def nm_menu(self):
        """
        Function that creates the menu for the tray icon.
        :return: The menu.
        """
        self.menu = Gtk.Menu()
        open_update = Gtk.MenuItem(label=_("Open Update"))
        open_update.connect("activate", self.left_click)
        close_item = Gtk.MenuItem(label=_("Close"))
        close_item.connect("activate", Gtk.main_quit)
        self.menu.append(open_update)
        self.menu.append(close_item)
        self.menu.show_all()
        return self.menu

    def left_click(self, status_icon: Gtk.StatusIcon):
        """
        Function that is called when the user left-clicks on the tray icon.
        :param status_icon: The status icon.
        """
        if updating():
            UpdateStationOpen()
        else:
            Data.stop_pkg_refreshing = True
            StartCheckUpdate()
        status_icon.set_visible(False)

    def icon_clicked(self, status_icon, button, time):
        """
        Function that is called when the user right-clicks on the tray icon.
        :param status_icon: The status icon.
        :param button: The button.
        :param time: The time.
        """
        position = Gtk.StatusIcon.position_menu
        self.nm_menu().popup(None, None, position, status_icon, button, time)

    def update_tray(self):
        """
        Function that updates the tray icon.
        """
        if check_for_update() is True:
            GLib.idle_add(self.status_icon.set_visible, True)
            notifier = UpdateNotifier()
            notifier.notify()
        else:
            GLib.idle_add(self.status_icon.set_visible, False)

    def threading_update(self):
        """
        Function that creates a thread that checks for updates.
        """
        if updating():
            unlock_update_station()
        thr = threading.Thread(target=self.check)
        thr.setDaemon(True)
        thr.start()

    def check(self):
        """
        Function that checks for updates.
        """
        while True:
            sleep(5)
            if repository_is_syncing() is False:
                if Data.stop_pkg_refreshing is False:
                    if not updating():
                        GLib.idle_add(self.update_tray)
                    else:
                        GLib.idle_add(self.status_icon.set_visible, False)
            # Wait for an hour to look for update
            # sleep(3480)
            sleep(120)


class InstallUpdate:
    """
    The class for the window that is displayed the progress of the update.
    """
    def close_application(self, widget, data):
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor for the InstallUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Installing Update"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.win.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        # self.pbar.set_size_request(-1, 20)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(target=self.read_output, args=[self.pbar])
        self.thr.setDaemon(True)
        self.thr.start()

    def update_progress(self, progress, fraction, text):
        """
        Function that updates the progress bar.
        :param progress: The progress bar.
        :param fraction: The fraction to add.
        :param text: The text to display.
        """
        progress.set_fraction(fraction)
        progress.set_text(text)

    def read_output(self, progress):
        """
        Function that reads the output of the update to update the progress bar.
        :param progress: The progress bar.
        """
        fail = False
        update_pkg = False
        option = ''
        packages = ''
        need_reboot_packages = set(json.loads(open(f'{lib_path}/need_reboot.json').read()))
        upgrade_packages = set(re.split(": | ", " ".join(Data.packages_dictionary['upgrade'])))
        reboot = bool(need_reboot_packages.intersection(upgrade_packages))
        if len(Data.packages_dictionary['upgrade']) == 1 and 'pkg:' in Data.packages_dictionary['upgrade'][0]:
            update_pkg = True
            packages = ' pkg'
            Data.second_update = True
        else:
            Data.second_update = False
        if Data.packages_dictionary['system_upgrade'] is True:
            option = 'f'
        howmany = (Data.total_packages * 5) + 10
        fraction = 1.0 / howmany
        if Data.backup:
            today = datetime.datetime.now().strftime("%Y-%m-%d")
            txt = _("Cleaning old boot environment")
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            for be in bectl.get_be_list():
                if 'backup' in be and today not in be and 'NR' not in be:
                    bectl.destroy_be(be.split()[0])
            backup_name = datetime.datetime.now().strftime("backup-%Y-%m-%d-%H-%M")
            txt = _("Creating boot environment")
            txt += f" {backup_name}"
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            bectl.create_be(newBeName=backup_name)
            sleep(1)
        txt = _("Fetching package updates")
        new_val = progress.get_fraction() + fraction
        GLib.idle_add(self.update_progress, progress, new_val, txt)
        sleep(1)
        fetch = Popen(
            f'pkg upgrade -Fy{option}{packages}',
            shell=True,
            stdout=PIPE,
            stderr=PIPE,
            close_fds=True,
            universal_newlines=True
        )
        fetch_text = ""
        while True:
            stdout_line = fetch.stdout.readline()
            if fetch.poll() is not None:
                break
            fetch_text += stdout_line
            new_val = progress.get_fraction() + fraction
            GLib.idle_add(self.update_progress, progress, new_val,
                          stdout_line.strip())
        if fetch.returncode != 0:
            stderr_line = fetch.stderr.read()
            fetch_text += stderr_line
            update_fail = open(f'{home}/update.failed', 'w')
            update_fail.writelines(fetch_text)
            update_fail.close()
            fail = True
        else:
            new_val = progress.get_fraction() + fraction
            txt = _("Package updates downloaded")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            new_val = progress.get_fraction() + fraction
            txt = _("Installing package updates")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            while True:
                install = Popen(
                    f'pkg upgrade -y{option}{packages}',
                    shell=True,
                    stdout=PIPE,
                    stderr=PIPE,
                    close_fds=True,
                    universal_newlines=True
                )
                install_text = ""
                while True:
                    stdout_line = install.stdout.readline()
                    if install.poll() is not None:
                        break
                    install_text += stdout_line
                    new_val = progress.get_fraction() + fraction
                    GLib.idle_add(self.update_progress, progress, new_val,
                                  stdout_line.strip())
                if install.returncode == 3:
                    stderr_line = install.stderr.readline()
                    if 'Fail to create temporary file' in stderr_line:
                        raw_line = install_text.splitlines()[-2]
                        failed_package = raw_line.split()[2].replace(':', '')
                        pkg_rquery = run(
                            f'pkg rquery -x "%n" "{failed_package}"',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            universal_newlines=True
                        )
                        package_name = pkg_rquery.stdout.strip()
                        reinstall = Popen(
                            f'pkg delete -y {package_name} ;'
                            f' pkg install -y {package_name}',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            close_fds=True,
                            universal_newlines=True
                        )
                        reinstall_text = ""
                        while True:
                            stdout_line = reinstall.stdout.readline()
                            if reinstall.poll() is not None:
                                break
                            reinstall_text += stdout_line
                            new_val = progress.get_fraction() + fraction
                            GLib.idle_add(self.update_progress, progress,
                                          new_val, stdout_line.strip())
                        if reinstall.returncode != 0:
                            reinstall_text += reinstall.stderr.readline()
                            update_fail = open(f'{home}/update.failed', 'w')
                            update_fail.writelines(reinstall_text)
                            update_fail.close()
                            fail = True
                            break
                        else:
                            new_val = progress.get_fraction() + fraction
                            txt = _("Reinstalling")
                            txt += f" {failed_package} "
                            txt += _("completed")
                            GLib.idle_add(self.update_progress, progress, new_val, txt)
                            sleep(1)
                elif install.returncode != 0:
                    stderr_line = install.stderr.readline()
                    install_text += stderr_line
                    update_fail = open(f'{home}/update.failed', 'w')
                    update_fail.writelines(install_text)
                    update_fail.close()
                    fail = True
                    break
                else:
                    new_val = progress.get_fraction() + fraction
                    txt = _("Software packages upgrade completed")
                    GLib.idle_add(self.update_progress, progress, new_val, txt)
                    sleep(1)
                    break
        GLib.idle_add(self.win.destroy)
        GLib.idle_add(self.stop_tread, fail, update_pkg, reboot)

    def stop_tread(self, fail: bool, update_pkg: bool, reboot:bool):
        """
        The function to stop the thread.
        :param fail: True if update failed.
        :param update_pkg: True if update pkg was updated first..
        :param reboot: True if system needs to be rebooted after update completed.
        """
        self.thr.join()
        if updating():
            unlock_update_station()
        if fail is True:
            Data.update_started = False
            Data.stop_pkg_refreshing = False
            FailedUpdate()
        else:
            if update_pkg is True and check_for_update() is True:
                Data.packages_dictionary = get_pkg_upgrade_data()
                StartCheckUpdate()
            else:
                Data.update_started = False
                Data.stop_pkg_refreshing = False
                if reboot is True:
                    RestartSystem()
                else:
                    UpdateCompleted()


class FailedUpdate:
    """
    FailedUpdate class for failed update window.
    """

    def get_detail(self, widget):
        Popen(f'sudo -u {username} xdg-open {home}/update.failed', shell=True)

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the FailedUpdate class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        # self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Failed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(vBox)
        vBox.show()
        label = Gtk.Label()
        failed_text = _("""Press "Detail" to get information about the failure.
        Get help at https://forums.ghostbsd.org.""")
        label.set_markup(failed_text)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        vBox.pack_start(hBox, False, True, 5)
        hBox.show()
        restart = Gtk.Button(label=_("Detail"))
        restart.connect("clicked", self.get_detail)
        continue_button = Gtk.Button(label=_("Close"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(continue_button, False, False, 5)
        hBox.pack_end(restart, False, False, 5)
        self.window.show_all()


class RestartSystem:
    """
    RestartSystem class for restarting system window.
    """
    def on_reboot(self, widget):
        """
        The function to reboot the system.
        :param widget: The window widget.
        """
        Popen('shutdown -r now', shell=True)
        Gtk.main_quit()

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the RestartSystem class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        # self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(vBox)
        vBox.show()
        reboot_text = _("The computer needs to restart to run on the updated software.")
        label = Gtk.Label(label=reboot_text)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        vBox.pack_start(hBox, False, True, 5)
        hBox.show()
        restart = Gtk.Button(label=_("Restart Now"))
        restart.connect("clicked", self.on_reboot)
        continue_button = Gtk.Button(label=_("Restart Later"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(restart, False, False, 5)
        hBox.pack_end(continue_button, False, False, 5)
        self.window.show_all()


class UpdateCompleted:
    """
    Class for update completed window.
    """

    def on_close(self, widget: Gtk.Widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateCompleted class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(vBox)
        vBox.show()
        rtxt = _("""All software on this system is up to date.""")
        label = Gtk.Label(label=rtxt)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        vBox.pack_start(hBox, False, True, 5)
        hBox.show()
        close_button = Gtk.Button(label=_("Close"))
        close_button.connect("clicked", self.on_close)
        hBox.pack_end(close_button, False, False, 5)
        self.window.show_all()


class NoUpdateAvailable(object):
    """
    Class for no update available window.
    """

    def __init__(self):
        """
        The constructor of the NoUpdateAvailable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("No Update Available"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("No update available. This system is up "
                          "to date."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class StartCheckUpdate:
    """
    Class for start check for update window.
    """
    def close_application(self, widget: Gtk.Widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor of the StartCheckUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Looking For Updates"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.win.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(
            target=self.check_for_update,
            args=[self.pbar]
        )
        self.thr.setDaemon(True)
        self.thr.start()

    def update_progress(self, progress: Gtk.ProgressBar, text: str):
        """
        The function to update the progress bar.
        :param progress: The progress bar.
        :param text: the text to be displayed on the progress bar.
        """
        progress.set_text(text)
        fraction = progress.get_fraction() + 0.2
        progress.set_fraction(fraction)

    def check_for_update(self, progress: Gtk.ProgressBar):
        """
        The function to check for update and update the progress bar.
        :param progress: The progress bar.
        """
        GLib.idle_add(self.update_progress, progress,
                      _('Checking if the repository is online'))
        sleep(1)
        if network_stat() == 'UP' and repo_online() is True:
            GLib.idle_add(self.update_progress, progress,
                          _('The repository is online'))
            sleep(1)
            if repository_is_syncing() is True:
                GLib.idle_add(self.update_progress, progress,
                              _('The mirror is Syncing'))
                GLib.idle_add(self.stop_tread, MirrorSyncing)
            else:
                if updating():
                    GLib.idle_add(self.update_progress, progress,
                                  _('Updates are already running'))
                    GLib.idle_add(self.stop_tread, UpdateStationOpen)
                else:
                    GLib.idle_add(self.update_progress, progress,
                                  'Checking for updates')
                    update_available = check_for_update()
                    if update_available:
                        GLib.idle_add(self.update_progress, progress,
                                      _('Getting the list of packages'))
                        Data.packages_dictionary = get_pkg_upgrade_data()
                        look_update_station()
                        GLib.idle_add(self.update_progress, progress,
                                      _('Open the update window'))
                        GLib.idle_add(self.stop_tread, UpdateWindow)
                    elif not update_available and update_available is not None:
                        GLib.idle_add(self.update_progress, progress,
                                      _('No update found'))
                        GLib.idle_add(self.stop_tread, NoUpdateAvailable)
                    else:
                        GLib.idle_add(self.stop_tread, SomethingIsWrong)
        else:
            GLib.idle_add(self.update_progress, progress,
                          _('The Mirror is unreachable'))
            GLib.idle_add(self.stop_tread, ServerUnreachable)

    def stop_tread(self, start_window: object):
        """
        The function to stop the thread.
        :param start_window: The start window object.
        """
        start_window()
        self.win.hide()
        self.thr.join()


class UpdateStationOpen(object):
    """
    Class for update station already started window.
    """
    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateStationOpen class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Station already started"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("Update Station already open."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", self.on_close)
        box2.pack_end(ok_button, False, False, 0)
        self.window.show_all()


class MirrorSyncing(object):
    """
    Class for the mirror is syncing warning window.
    """

    def __init__(self):
        """
        The constructor of the MirrorSyncing class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("Packages mirrors are syncing with new "
                          "packages"))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class ServerUnreachable(object):
    """
    Class for the server unreachable warning window.
    """

    def __init__(self):
        """
        The constructor of the ServerUnreachable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("The server is unreachable. Your internet "
                          "could\nbe down or software package server is down."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class SomethingIsWrong(object):
    """
    Class for the something is wrong warning window.
    """

    def __init__(self):
        """
        The constructor of the SomethingIsWrong class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Something Is Wrong"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_(
                          "If you see this message it means that "
                          "something is wrong.\n Please look at pkg upgrade "
                          "output."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class NotRoot(Gtk.Window):
    """
    Class for the user is not root warning window.
    """
    def __init__(self):
        """
        The constructor of the NotRoot class.
        """
        Gtk.Window.__init__(self)
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(200, 80)
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.add(box1)
        box1.show()
        label = Gtk.Label(label=_('You need to be root'))
        box1.pack_start(label, True, True, 0)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        hBox.show()
        box1.pack_end(hBox, False, False, 5)
        ok_button = Gtk.Button()
        ok_button.set_label(_("OK"))
        apply_img = Gtk.Image()
        apply_img.set_from_icon_name('gtk-ok')
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", Gtk.main_quit)
        hBox.pack_end(ok_button, False, False, 5)
        self.show_all()


arg = sys.argv
UsageMSG = f"""
Usage for {arg[0]}:

Available Commands:

check-now       - Look for update now

"""


if os.geteuid() == 0:
    if len(arg) == 1:
        if socket.gethostname() != 'livecd':
            Data.close_session = False
            tray = TrayIcon()
            tray.threading_update()
        else:
            exit()
    elif len(arg) == 2 and arg[1] == "check-now":
        Data.close_session = True
        StartCheckUpdate()
    else:
        print(UsageMSG)
        sys.exit(0)
else:
    NotRoot()
Gtk.main()
